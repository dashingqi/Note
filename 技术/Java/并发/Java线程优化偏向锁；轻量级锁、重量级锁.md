## Java线程优化

#### 简介

- Java的线程是映射到操作系统原生线程之上的。
- 当我们要阻塞或者唤醒一个线程就需要操作系统的帮忙，就要从用户态转换到核心态。
- 可能我们执行的语句的时间，都没有线程状态转换的时间长。
- Java里synchronized是一个重量级的操作。

#### Synchronized的实现原理

> 在搞清楚synchronized的原理之前，需要明白对象头和Monitor

##### 对象头

- 一个Java对象在内存中的布局分为三个部分
  - 对象头
  - 实例数据
  - 对其填充
- 当我们使用new关键字来创建一个对象的时候，会在内存中创建一个instanceOopDesc对象，该对象包括了对象头和实例数据。

###### instanceOopDesc

- 它的基类为oopDesc

  ```java
  //它的内部组成中 _mark 和_metadata 一起组成了对象头
  //其中 _metaData表示的是元数据，而_mark是markOop类型的数据，一般称它为标记字段（Mark Word）
  // _mark中主要存储了hashCode、分代年龄、锁标志位、是否偏向锁等
  ```

- 当锁是重量级锁时，对象头中Mark Word会用30bit来指向一个互斥量，这个互斥量就是Monitor

##### Monitor

- Monitor 可以把它作为一个同步工具，也可以理解为一种同步机制。
- 它是一个保存在对象头中的一个对象。
- 在JVM中ObjectMonitor是Monitor的具体实现
  - 在markOop中我们可以通过monitor()方法创建一个ObjectMonitor对象。
  - Java中，每一个创建的对象的对象头中都会有一个ObjectMonitor对象，这也是Java对象能当作锁对象的原因。

###### ObjectMonitor实现同步的机制

- ObjectMonitor关键的属性

  ```java
  _owner: 指向持有ObjectMonitor对象的线程
  
  -WaitSet: 存放处于wait状态的线程（调用了wait()）
  
  -EntryList:存储处于等待锁状态的线程
  
  _resoursions：锁的重入次数
  
  _count：用来记录该线程获取锁的次数
  ```

- 用一段话描述下 如上几个属性的用处

  - 当多个线程访问同一个同步代码的时候，这时这些线程会存在 -EntryList中，如果此时有一个线程获得了执行权，那么-owner变量会设置为当前线程。同时计数器-count会加一。表示获取到了对象锁。
  - 当持有对象锁的线程调用了wait方法，此时该线程会存放在-WaitSet中，-owner会变成null，计数器-count减一。

- ObjectMonitor的同步机制

  - 它的同步机制是JVM对象操作系统级别的管理过程，每次否会从用户状态切换到系统内核态。
  - synchronized实现锁，是属于重量级别的，当多个线程来回切换都是关乎到与操作系统线程的切换，属于很重量级别的。

#### Java虚拟机对synchronzied的优化

- 在Java6之后，虚拟机在synchronzied关键字做了多方面的优化
- 优化的点就是减少对ObjectMonitor的访问，减少这个重量级的受用次数，减少线程从用户态和内核态的切换。

- 其中主要做了如下几个优化
  - 锁自旋
  - 轻量锁
  - 偏向锁

##### 锁自旋

- 所谓自旋，就是让线程等待一段时间，不会立刻被挂起。
- 看当前持有锁的线程是否会很快释放掉锁，
- 我们这里等待一段时间就是执行一段很没有意思的循环即可。
- 自旋锁存在的缺点
  - 自旋锁占用一定的CPU资源，如果当前线程持有的锁时间长，那么自旋锁就白白占用了CPU资源，此时应该主动禁用自旋锁。

##### 轻量级锁

- JVM中会存在这种情形
  - 对于同一块同步代码，虽然有多个不同线程会去执行，但是这些线程都是在不同的时间段去请求获得锁对象，也就是不存在锁竞争的情况下，在这种情况下，锁会保持在轻量级锁的状态。
- 轻量级锁所适应的场景是线程交替执行同步代码块场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。

##### 偏向锁

- 有些时候锁不仅存在多线程的竞争，而且总是由同一个线程获得。

- 如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作。
- 具体实现
  - 在锁对象的对象头中有个ThreadId字段，默认是为空的，当第一次获取锁的时候，将线程自身的ThreadId，写入到锁对象的Mark Word中的ThreadId中，将是否偏向锁的状态置为01.
  - 当下次获取锁的时候，会直接检查锁对象中的ThreadId和自身的ThreadId是否相同，相同的话就认为当前 线程已经获取到锁，不需要再次获取锁。跳过了轻量级和重量级的加锁阶段，提高了效率。

