## CAS

#### 什么是CAS

- CAS ----> Compare And Swap  比较并替换

- CAS机制中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B

#### 例子解释

- 内存地址V存在一个值为10的变量
- 此时线程1想要把变量的值加1；对于线程1来说旧的预期值A = 10，要修改的新值B = 11；
- 在线程1 要提交更新之前，线程2强先一步，把内存地址V中的变量更新成了11
- 线程1开始提交，首先进行旧的预期值和内存地址V的实际值进行比较，发现A不等于V中的实际值，那么就提交失败。
- 线程1重新获取地址V的当前值，并重新计算想要修改的新值，此时线程1来说 A = 11 ，B=12，这个尝试过程为自旋
- 这一次比较，没有其他线程修改地址V的值，线程1进行比较，发现A和地址V的实际值是相等，就进行交换值操作。

#### 从思想上来看

- Synchronized属于悲观锁：悲观的任务程序中的并发情况严重。
- CAS属于乐观锁：乐观认为程序中的并发情况不那么严重。
- 在并发量非常高的情况下，反而使用同步锁更合适一些。

#### 使用CAS机制的地方

- Atomic系列类的底层实现。
- Lock系列类的底层实现。

#### CAS的缺点

- CPU开销比较大
  - 在并发量比较高的情况下，如果很多线程反复尝试更新一个变量，却一直更新不成功，循环这个操作，会给CPU带来很大的压力。
- 不能保证代码块的原子性
  - CAS机制可以保证一个变量的原子性操作，却不能保证整个代码块的原子性。必须需要保证3个变量共同进行原子性的更新。就得使用synchronized了