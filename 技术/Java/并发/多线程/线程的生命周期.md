## 线程的生命周期

- 线程创建并启动以后，不是一下就进入执行状态，也不是一哦值处于执行状态
- 线程的生命周期主要有如下5种状态
  - 新建
  - 就绪
  - 运行
  - 阻塞
  - 死亡

#### 新建和就绪状态

- 当使用new关键字创建一个线程后，该线程处于新建状态。
- 当线程对象调用start方法后，线程处于就绪的状态。
  - 就绪状态表示当前线程可以运行了，
  - 至于什么时候开始运行，取决于JVM里面的线程调度器的调度。
  - 如果希望调用完start方法之后，立即开始执行，sleep(1)就足够

###### 通过线程对象直接调用run方法

- 这样只是立即执行了run方法，并没有开启线程。
- 直接通过线程对象调用run方法之后，该线程已经不是新建状态了，如果再次去调用start方法，会引发异常，抛出异常。

#### 运行和阻塞状态

###### 运行状态

- 如果处于就绪状态的线程获取到了CPU执行权，那么就开始执行run方法，该线程目前处于运行状态。

###### 阻塞状态

- 现代的桌面和服务器操作系统采用抢占式调度策略（系统会给每个可执行线程一个时间段来处理任务，处理完之后就会被系统剥夺执行权）
- 但是手机上则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或者yield方法后才会放弃所占用的资源。
- 当发生如下情况，线程会进入阻塞状态
  - 线程调用sleep方法，主动放弃执行权
  - 线程调用了一个阻塞式IO方法，在方法返回之前，该线程被阻塞。
  - 线程试图获得一个同步监视器，但是该同步监视器正被其他线程所持有。
  - 线程在等待某个通知（notify）
  - 程序调用了suspend方法将该线程刮起。这个方法容易导致死锁，尽量避免使用这种方法。
- 当阻塞的线程在合适的时机重新进入就绪状态，而不是运行状态
- 当发生了如下情况，线程从阻塞状态进入就绪状态
  - 调用sleep方法的线程过了指定时间
  - 线程调用的阻塞IO的方法已经返回
  - 线程成功的获取了同步监视器
  - 线程获取到正在等待的某个通知
  - 处于挂起的线程被调用了resume恢复方法。

#### 线程状态转换图

![线程状态转化图.png](https://upload-images.jianshu.io/upload_images/4997216-7278bf84e195dd33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 其中有一点，yield方法可以使运行状态直接返回到就绪状态。

#### 线程死亡状态

- 有如下几点能导致线程死亡
  - run()或者call()方法执行完毕，线程正常结束
  - 线程抛出了未捕获的Exceptiopn或者Error
  - 调用了stop来结束线程----该方法容易导致死锁，通常不推荐使用。
- 我们可以调用isAlive方法来判断当前线程是否死亡
  - 处于 就绪、运行、阻塞状态返回true。
  - 处于新建、死亡状态返回false。

- 线程死亡就是死亡，如果再次调用start方法将会引发异常。
  - 这个表明死亡的线程无法再次运行了。
  - 如果连续对同一个线程对象调用start方法也会抛出异常。