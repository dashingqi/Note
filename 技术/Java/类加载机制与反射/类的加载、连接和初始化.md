## 类的加载、连接和初始化

#### JVM和类

- 当我们调用Java的命令运行Java程序时，就会启动一个Java虚拟机进程，Java程序启动的线程都运行在Java虚拟机进程里。
- 同一个JVM的所有线程，所有变量都处于同一个进程里，它们都使用该JVM进程的内存区。
- 出现如下几种情况，JVM进程将被终止
  - 程序运行到最后正常结束。
  - 程序运行到使用System.exit()h或者Runtime.getRunTime().exit()代码处结束程序。
  - 程序执行过程中遇到为处理的异常或者错误而结束的。
  - 程序平台强制结束了JVM进程。

#### 类的加载

- 当程序主动使用某个类时，如果该类还没被加载到内存中，系统会通过加载、连接、初始化3个步骤对类进行初始化。有时也把这三个步骤统称为类加载或类初始化。
- 类加载指的是将类的.class文件读入到内存，并为之创建一个java.lang.Class对象。也就是说使用任何类时，系统都会为之建立一个java.lang.Class对象。
- 每个类是一批具有相同特征的对象的抽象，而系统中所有的类实际上也是实例，它们都是java.lang.Class的实例。

###### 类的加载器

- 类的加载是由类加载器完成，类加载器通常由JVM提供。
- JVM提供的这些类加载器通常称为系统类加载器。
- 除此之外，我们可以自己通过继承ClassLoader基类来创建自己的类加载器。
- 使用不同的类加载器，可以从不同来源加载类的二进制数据，有如下几种来源
  - 从本地文件系统加载.class文件。
  - 从JAR包中加载.class文件。
  - 通过网络加载.class文件
  - 把一个Java源文件动态编译，并执行加载。

#### 类的连接

> 类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，
>
> 连接阶段主要负责把类的二进制数据合并到JRE中。

- 类的连接分为如下3个阶段
  - 验证：用于检验被加载类是否有正确的内部结构。
  - 准备：是将类的静态变量分配内存，并设置默认初始值。
  - 解析：将类的二进制数据中的符号引用替换成直接引用。

#### 类的初始化

- 类的初始化阶段，虚拟机负责对类进行初始化，主要就是对静态变量进行初始化。
- 静态变量指定初始值有两种方式
  - 声明静态变量时指定初始值
  - 使用静态代码块时为静态变量指定初始值。
- 以上两种方式初始化静态变量时，JVM会按照这些语句在程序中的排列顺序依次执行它们。

###### JVM初始化一个类包含如下几个步骤

- 假如这个类还没有被加载和连接，那么程序先加载并连接该类。
- 假如该类的直接父类还没有被初始化，那么先初始化其直接父类。
- 假如类中有初始化语句，那么系统依次执行这些初始化语句。

##### 类的初始化时机

- 创建类的实例
- 调用某个类的静态方法
- 访问某个类或者接口的静态变量，或者为该静态变量赋值
- 使用反射方式来强制创建某.  个类或者接口对应的Java.lang.Class对象。
- 初始化某个类的子类：当初始化某个类的子类是，该子类的所有父类都会被初始化。
- 直接使用java.exe命令来运行某个主类。

###### 特别指出的

- 对于一个final类型的静态变量，在编译时期这个变量的值就可以确认。那么这个变量相当于宏变量

- 那么Java就会在编译时直接把这个Field出现的地方替换成它的值。

- 因此即使使用该静态变量，也不会导致该类的初始化。

- 当使用ClassLoader类的loadClass()方法来加载某个类时，该方法只是加载该类，并不会执行该类的初始化。

  - 如果使用Class.forName()的静态方法会导致强制初始化该类。

    ```java
    ClassLoader cl = ClassLoader.getSystemClassLoader();
    //仅仅是加载类
    cl.loadClass("类名")
    //该方法会加载并且初始化该类。
    Class.forName("类名")
    
    ```

    