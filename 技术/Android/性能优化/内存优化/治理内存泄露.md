## 堆内存治理

#### 内存治理的三板斧

压缩、回收、复用

## 创建线程发生OOM

- 使用线程池，可以避免线程的重复；
- 池化作用可以让线程起到复用；避免频繁GC；
- 重复创建线程，一个线程的创建对应内存就会创建对应的虚拟机栈、本地方法栈、程序计数器这种线程独享；

## FD泄露导致OOM

#### 控制FD的数量

- IO及时关闭

- Cursor实例及时关闭
- 及时释放HandlerThread

- kotlin的use高阶函数,函数式编程可无需关注 close()

## 内存优化的方法论

#### Reduce缩减

- 降低图片分辨率/重采样/抽稀策略（地图）；

#### Reuse复用

- 池化策略/避免频繁创建对象，减小GC 压力；

###### Bitmap内存治理

- 根据实际需求选择合适的分辨率；
- 原始文件分辨率与内存缩放的结果，对于本地内置的图片文件，要放置到正确的文件夹中；
- 不使用帧动画，尽量使用代码实现动画；

- 压缩、复用；---> 减小GC的压力
  - 重采样，保证 imageview 所需的真实大小；
  - 复用：Bitmap的复用--> BitmapFactory inMutable = true

- 缓存
  - 网络/磁盘/内存
  - 缓存算法分析 ---> LRU算法 数据结构LinkedHashMap
  - 熟悉的框架为例子

![image-20230716172352031](https://raw.githubusercontent.com/dashingqi/DQPicBeg/main/image-20230716172352031.png)

#### Recycle回收

> 主动销毁、结束，避免内存泄露/生命周期的闭环；

###### 内存泄露

- 静态或者单利持有；
- 被生命周期长的对象所持有；
- 匿名内部类
  - Handler
  - 静态的内部类+WeakReference持有Activity

#### Refactor重构

>  更合适的数据结构/更合理的程序框架；

###### 酌情使用枚举

- @IntDef注解

###### 避免装箱带来的内存开销

- Integer i = 1;

- HashMap<Integer,String> ---> SpareArray()
- Array<Int> ---> intArray<Int>
- kotlin中使用Int?接受可空类型

#### Revalue重审

>  谨慎使用 Large Heap/多进程/第三方框架；

###### 谨慎使用多进程

- 厂商限制应用的内存占用

###### 谨慎使用Large Heap

- android:largeHeap="true"；
- 内存过大，GC回收也会耗时；

###### 使用NDK

- Native Heap 没有专门的使用限制
- 内存大户的逻辑都在native层
  - 游戏引擎
  - 地图渲染引擎

#### 匿名内部类&lambda&高阶函数内存泄露的隐患

|         名称         | 隐式持有外部类引用 | 生成匿名类文件 |           泄露风险            |      |
| :------------------: | :----------------: | :------------: | :---------------------------: | ---- |
|   Java 匿名内部类    |         是         |       是       | 显/隐式持有外部类引用，有风险 |      |
|  Java lambda表达式   |         否         |       否       |  显式持有外部类引用，有风险   |      |
|  Kotlin 匿名内部类   |         否         |       是       |  显式持有外部类引用，有风险   |      |
| Kotlin lambda 表达式 |         否         |       否       |  显式持有外部类引用，有风险   |      |
|   kotlin 高阶函数    |         否         |       是       |  显式持有外部类引用，有风险   |      |

