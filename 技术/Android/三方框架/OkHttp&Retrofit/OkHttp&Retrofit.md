#### Retrofit

###### 基本描述

- Retrofit是基于 RESTFul风格API，封装OkHttp的网络请求框架；
- 在使用时通过运行时注解来构造采集请求的参数，使用预定义好的接口通过动态代理来获取网络请求的实例；

- 采用建造者模式来构建Retrofit实例
- 采用适配器模式，提供 GSON/RxJava 的适配器将数据抓换成业务所需的数据 Bean；
- create()方法采用门面的设计模式对于内部的缓存以及动态代理调用过程隐藏化；

###### 优点

- 运行时注解，将网络请求抽象化，便于代码编写；
- 将请求到的数据从工作线程主动切换到主线程中；
- 支持设置拦截器；
- 默认支持 GZip 的压缩，在头部加入默认的请求头参数；

#### OKHttp

##### 拦截器

###### 重试重定向拦截器

- 当请求失败或者收到3XX响应码时，该拦截器内部会开启一个 while(true)循环，进行重新发起网络请求当收到网络请求成功之后或者到达重试次数之后就会退出这个循环；

###### 桥接拦截器

- 对 Http 的请求头进行加工，加入协议参数，比如（Accecpt-encoding:Gzip);

###### 缓存拦截器

- 顾名思义就是将请求的 response 进行本次持久化，采用策略是DiskLruCache，根据请求的 url 获取response，然后根据协议中的参数来决定是复用缓存还是重新发起请求；
- 仅仅缓存Get请求（幂等和安全性考虑）Post 请求任务不是幂等和安全性；
  - 幂等性：代表一个资源进行多次操作和一次操作请求得到的结果是一致的；
  - 安全性：代表本次请求不对服务器资源产生任何副作用；
- 是通过空间换取时间的策略；采用的算法LRU；
- 缓存能减缓服务器压力，能让客户端有更好的体验，主要体验在快上；
- 相应头中max-age、cache-control标识过期时间；
- 相应头中 Last-Modified代表资源最近一次修改时间，下次请求时客户端带上该标识，如果服务器时间大于该时间返回 200，否则返回 304 代表缓存有效；
- 无网环境下，即使缓存处于过期也应该使用缓存，客户端自定义拦截器，对request的head中改cache-control字段为FORCE_CACHE

###### 链接拦截器

- 建立链接 tcp，维护了一个链接池
- 链接复用
  - 建立 Tcp链接需要三次握手，以及后面需要 tls 都是比较耗时的
  - 统一域下建立好的 tcp 链接可以达到复用的状态，避免耗时；
  - 链接池中一个地址最多维护 5 个空闲链接，一个空闲链接最多存活 5 分钟；

###### 请求拦截器

- 处理请求数据，包括请求头和请求body
- 处理响应的数据；读取相应头以及构建 ResponseBody

