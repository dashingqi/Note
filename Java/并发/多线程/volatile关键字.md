## volatile关键字

#### Java内存模型

- Java中的堆内存用来存储对象实例，堆内存是被所有线程共享的运行时内存区域。
- 局部变量、方法定义的参数则不会在线程之间共享。
- 线程之间的共享变量存储在主存中，每个线程都有一个私有的本地内存。本地内存中存储了该线程的共享变量的副本。
- 本地内存是Java内存模型中的一个抽象改变，其实不真实存在，它涵盖了缓存、写缓存、寄存器等区域。

#### 原子性

- 对基本数据类型变量的读取和赋值操作是原子性操作。
- 一个语句中含有多个操作时，就不是原子性操作，只有简单的读取和赋值才是原子性操作。

#### 可见性

- 是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的，也就是一个线程修改的结果，另一个线程马上就能看到。
  - 当一个变量被volatile修饰时，它会保证修改的值立即被更新到主存，所以对其他线程时可见的。
  - 对于普通的变量来说就不能保证可见性，因为普通的变量被修改时，并不会立即被写到主存时，何时被写入也是未知的，当有其他线程去读取该值时，此时主存中可能还是原来的旧值，就无法保证可见性。

#### 有序性

- Java内存模型中允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程执行的正确性，但是会影响到多线程并发执行的正确性
- 可以通过volatile来保证有序性，处理volatile也可以通过synchronized和Lock来保证有序性。
- 我们知道synchronized和lock保证每个时刻只能有一个线程来执行同步代码。

#### volatile关键字

- 当一个变量被volatile关键字修饰后，就具备两个含义了
  - 一个线程改变了变量的值时，变量的新的值对于其他线程来说时立即可见的。
  - 禁止使用了指令重排序。

###### 重排序

- 通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。
- 重排序分为两类
  - 编译期重排序----> 对应于编译时环境
  - 运行期重排序 -----> 对应于运行时环境

###### volatile不保证原子性

###### volatile保证有序性

- volatile能禁止指令重排序，因此volatile能保证有序性。
- 在进行指令优化的时候，在volatile变量之前的语句不能在volatile变量后面执行；同样在volatile变量之后的语句也不能在volatile变量前面执行。

