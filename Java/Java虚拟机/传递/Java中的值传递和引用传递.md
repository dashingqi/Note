

## 值传递和引用传递

> 参考：https://juejin.im/post/5bce68226fb9a05ce46a0476

#### 形参和实参

#### Java的数据类型

###### 基本数据类型

###### 引用数据类型

#### JVM内存划分

> Java语言是不能操作内存的，都是有JVM来进行分配和管理的

***所谓的JVM虚拟机开辟的内存空间 开的内存空间叫做 运行时数据区***

###### 运行时数据区的组成

- 虚拟机栈
- 堆
- 程序计数器
- 本地方法栈
- 方法区

###### 虚拟机栈

- 虚拟机栈是Java方法执行的内存模型，虚拟机栈找那个存放着栈帧，每一个栈帧对应着一个被调用的方法。
- 虚拟机栈时线程私有的。
- 当某一个线程中的一个方法执行，就会创建相应放入一个栈帧并且入栈，位于栈顶，等到方法结束后就出栈。
- 对这个区域规定了两种异常情况
  - StackOverflowError：当线程请求栈深度超出虚拟机栈所允许的深度时抛出。
  - OutOfMemoryError：当Java虚拟机动态扩展到无法申请足够内存时抛出。
- 一个线程虚拟机栈中有多个栈帧。
- 栈帧包含如下
  - 局部变量表：是变量值的存储空间
    - 我们调用方法时传递的参数。
    - 在方法内部创建的局部变量保存在局部变量表。
  - 操作数栈：也称之为操作栈，是一个先入后出的栈。
  - 动态连接：是为了支持方法调用过程中的动态连接
    - 
  - 返回地址
    - 当一个开始执行后，只有两种方式可以退出这个方法。
      - 正常退出：执行过程中，没有抛出任何异常
      - 异常退出：执行过程中遇到异常，导致方法退出。
    - 无论采用何种方法退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行。
    - 虚拟机栈中的返回地址就时用来帮助当前方法恢复它的上层方法执行状态。
- 注意：
  - 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）

###### 堆

- 堆是用来存储对象和数组的，在JVM中只有一个堆，线程共享的。

- 它是Java垃圾收集器管理的主要区域。

- 按照对象存储时间的不同，堆中的内存可以划分为新生代和老年代，其中新生代又被划分为Eden和Survivor区

  - 如下图

    ![堆内存的划分.png](https://upload-images.jianshu.io/upload_images/4997216-537947944f13680a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

  - 图中不同区域存放具有不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，进而提高垃圾回收效率。

###### 方法区

- 方法区在JVM中只有一个，是线程共享的。用来存储线程共享的内容
- 主要用来存储常量池（字段，方法，静态变量，类型引用（class）），类的全路径名，类的直接超类的全限定名，类的访问修饰符，类的类型（类或者接口）
- 关于方法区会跟永久区混淆，进行一下对比
  - 方法区是JVM规范中规定的一块区域，并不是实际实现。不同的JVM厂商可以有不同版本的方法去实现。
  - 在JDK1.7之前使用永久区实现方法区；之后就把永久区给移除了，取而代之的是 元空间来实现方法区。

###### 本地方法栈

- 本地方法栈是和虚拟机栈功能一样的，也是线程私有的。
- 虚拟机栈对应着Java中的方法执行，而本地方法栈是对应着本地方法的执行，也就是native层的方法。

###### 程序计数器

- 记录当前线程所执行的字节码的行号指示器。
- 对这个区域有如下几点需要注意
  - 在Java虚拟机规范中，对程序计数器这一区域没有规定 OutOfMemoryError
  - 程序计数器是线程私有的。
  - 当一个线程正在执行一个Java方法时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址。如果正在执行的是Native方法。这个计数器的值为空。

#### 数据在内存中的存储

###### 基本数据类型

- 基本数据类型的局部变量
  - 数据的变量和值都放在虚拟机栈中
- 基本数据类型的成员变量
  - 变量名和值都存储在堆中，生命周期和对象是一致的。
- 基本数据类型的静态变量
  - 变量的名字和值都存放在方法区的常量池中。
  - 静态变量随着类的加载而加载，随着类的消失而消失。

###### 引用数据类型的存储

- 变量名字存放在虚拟机栈中，变量存储的是对象的内存地址值，真正的对象是存放在堆中的。

#### 值传递和引用传递

###### 值传递

> 我们在调用方法的时候。通过方法的形参把我们的实参的内容副本传递到方法内部了，
>
> 此时形参接受的是一个真实内容的拷贝，在方法内部对这个形参的操作都是对这个副本的操作。

- 几个点
  - 方法中的局部变量是存储在虚拟机栈的栈帧中，方法的结束对应的栈帧就出栈。
  - 我们通过方法的形参传递的是实参的一个内容副本。操作的是内容副本。

###### 引用传递

> 引用存储着 我们真实对象在堆中的内存地址值，在我们进行方法调用的时候，实参存储的地址通过形参传入到方法内部，在方法体内部，形参和实参都执向同一个内存地址，对形参的操作会影响真实内容。

- 引用传递在Java中是不存在的。传递还是引用的副本。
- 当在方法重新给形参赋一个新对象，无论怎么操作都不会影响之前的实参的引用对应的对象
- 当在方法内没有进行重新分配，那么副本操作对象内容，会导致对象内容发生改变。



